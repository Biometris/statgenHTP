---
title: "statgenHTP tutorial: 3. Correction for spatial trends"
author: "Emilie Millet, Bart-Jan van Rossum"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: yes
    toc: no
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{SpatialModel} 
  %\VignetteEncoding{UTF-8} 
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
  )
library(statgenHTP)
```

# Introduction 

Phenotyping facilities display spatial heterogeneity. For example, the spatial variability
of incident light can go up to 100% between pots within a greenhouse [@Cabrera2016]. 
Taking into account these spatial trends is a prerequisite for precise estimation of 
genetic and treatment effects. In the same way as in field trials, platform experiments 
should obey standard principles for experimental design and statistical modeling.

Popular mixed models to separate spatial trends from treatment and genetic effects, rely 
on the use of autoregressive correlation functions defined on rows and columns (AR1×AR1) 
to model the local trends [@Cullis2006]. These models are sometimes difficult to fit and 
the selection of a best model is complicated, therefore preventing an automated 
phenotypic analysis of series of trials. An attractive alternative is the use of 
2-dimensional P-spline surfaces, the SpATS model (Spatial Analysis of Trials using Splines, 
[@RodAlv2018]). This model corrects for spatial trends, row and column effects and has 
the advantage of avoiding the model selection step. It also provides the user with 
graphical output that are easy to interpret. It has proven to be a good alternative to the 
classical AR1×AR1 modeling in the field [@Velazco2017]. It is also suitable for 
phenotyping platform data and has been tested on several datasets in the
EPPN^2020^ project. 

The aim of this document is to accurately separate the genetic effects from the spatial 
effects at each time point. It will provide user with either genotypic values or corrected
values that can be used for further modeling. 

This tutorial describes in detail how to perform analyses to correct for spatial trends using different modeling engines and extract the results from the models.

----

# Modeling with spatial terms using Example 1

We will use the TP object `phenoTPOut` in which annotated time points have been replaced by NA (see *OutliersTime...HTP*).

```{r createTP, warning=FALSE, echo=FALSE}
PhenovatorDat1 <- PhenovatorDat1[!PhenovatorDat1$pos %in% c("c24r41", "c7r18", "c7r49"),]
phenoTP <- createTimePoints(dat = PhenovatorDat1,
                            experimentName = "Phenovator",
                            genotype = "Genotype",
                            timePoint = "timepoints",
                            repId = "Replicate",
                            plotId = "pos",
                            rowNum = "y", colNum = "x",
                            addCheck = TRUE,
                            checkGenotypes = c("check1", "check2", "check3", "check4"))
resuVatorHTP <- detectPointOutliers(TP = phenoTP,
                                    trait = "EffpsII",
                                    confIntSize = 3,
                                    mylocfit = 0.1)
phenoTPOut <- removePointOutliers(phenoTP,
                                  resuVatorHTP)
```

After creating a `TP` object, a model can be fitted on the data. This is done 
using the function `fitModels`, which uses two different engines for fitting the models, namely
*SpATS* [@RodAlv2018] and *ASReml* [@Gilmour2017]. For models with row and column coordinates,
SpATS is the default engine (see part [**2.1**](#spats)). This can  be overruled by specifying the 
function parameter `engine` and using asreml for spatial models (see part [**2.2**](#asreml)). When the 
row and column coordinates are not available, asreml is used for modeling without 
spatial components (see part [**2.3**](#asremlnoSP)). Finally, it is possible to decompose the genotypic 
variance using, for example, a treatment effect (see part [**2.4**](#genodecomp)).

The output of `fitModels` is an object of class `fitMod`, a list of fitted models with one item for each time point the model was fitted for. 

## Spatial model using SpATS {#spats}

When SpATS is used for modeling, an extra spatial term is included in the model. This spatial component is composed using the `PSANOVA` function in the SpATS package which uses 2-dimensional smoothing with P-splines as described in @Lee2013 and in @RodAlv2018. 
See `help(PSANOVA, SpATS)` for a detailed description. Extra fixed effects may be fitted using the option `extraFixedFactors`. The model can also be fitted following a resolvable row-column design setting `useRepId` as `TRUE`. The model specifications are listed in the table below. 

option | model fitted | spatial term |
--------------------|-----------------------------------------|-----------------|
default | trait = **genotype** + **$\epsilon$** | PSANOVA |
extraFixedFactors = c("A","B") | trait = *A* + *B* + **genotype** + **$\epsilon$** | PSANOVA |
useRepId = TRUE | trait = *repId* + **genotype** + **repId:rowId** + **repId:colId** +  **$\epsilon$** | PSANOVA |
useCheck = TRUE | trait = *check* + **genoCheck** +  **$\epsilon$** | PSANOVA |

In the models above, fixed effects are indicated in *italics* whereas random effects are indicated in **bold**. "genotype" can be fitted as **random** or *fixed* effect using the option `what`. The same model will run with genotype as fixed. The option `useCheck` allows treating some genotypes as check: it splits the column "genotype" into two columns as follows:

<center>

| genotype | check | genoCheck |
|:----------:|:----------:|:----------:|
| G~1~ | noCheck | G~1~ |
| G~2~ | noCheck | G~2~ |
| ... | noCheck | ... |
| G~n-1~ | noCheck | G~n-1~ |
| G~n~ | noCheck | G~n~ |
| check~1~ | check~1~ | NA |
| check~2~ | check~2~  | NA |
| ... | ... | ... |
| check~m-1~ | check~m-1~ | NA |
| check~m~ | check~m~ | NA |

</center>

> *Note that it is only possible to use the combination of check and genotype as random.*


### Calling SpATS

Using the `TP` object "phenoTPOut" from the previous section, a model for a few time points 
and trait "EffpsII" can now be fitted on the data as follows. Since `engine` is not supplied 
as an option, SpATS is used for fitting the following model:  
EffpsII = **genotype** + **rowId** + **colId** + **$\epsilon$**

```{r fitSp, message=FALSE}
## Fit a model for a few time points.
modPhenoSp <- fitModels(TP = phenoTPOut, 
                        trait = "EffpsII",
                        timePoints = seq(from = 1, to = 73, by = 5)) 
summary(modPhenoSp)
```

The output is a `fitMod` object, a list containing one fitted model per time point. Note that by not 
supplying the `what` argument to the function, genotype is set as random. 

It can be run again with genotype as fixed using `what`:  
EffpsII = *genotype* + **rowId** + **colId** + **$\epsilon$**

```{r fitSpFix, message=FALSE, eval=FALSE}
## Fit a model for a single time point.
modPhenoSpFix <- fitModels(TP = phenoTPOut, 
                           trait = "EffpsII",
                           timePoints = 3,
                           what = "fixed")
```

The model can be extended by including extra main fixed effects:  
EffpsII = *repId* + *Image_pos* + **genotype** + **rowId** + **colId** + **$\epsilon$**

```{r fitSpCov, message=FALSE, eval=FALSE}
## Fit a model for a single time point with extra fixed factors.
modPhenoSpCov <- fitModels(TP = phenoTPOut, 
                           trait = "EffpsII",
                           extraFixedFactors = c("repId", "Image_pos"), 
                           timePoints = 3)
```

It can also be extended by including check genotypes:  
EffpsII = *repId* + *Image_pos* + *check* + **genoCheck** + **rowId** + **colId** + **$\epsilon$**

```{r fitSpCheck, message=FALSE, eval=FALSE}
## Fit a model for a single time point with extra fixed effects and check   genotypes.
modPhenoSpCheck <- fitModels(TP = phenoTPOut, 
                             trait = "EffpsII",
                             extraFixedFactors = c("repId", "Image_pos"),
                             useCheck = TRUE,
                             timePoints = 3)
```

Finally, a model following a resolvable row-column design can be fitted: including the
interactions between replicate and row-col.  
EffpsII = *repId* + **genoCheck** + **repId:rowId** + **repId:colId** + **$\epsilon$**

```{r fitSpRCD, message=FALSE, eval=FALSE, eval=FALSE}
## Fit a model for a single time point.
modPhenoSpRCD <- fitModels(TP = phenoTPOut,
                           trait = "EffpsII",
                           timePoints = 3,
                           useRepId = TRUE)
```

### Model plots

The first type of plot that can be made for fitted models, is a spatial plot per time 
point using `plotType = "spatial"`. It consists of five plots, spatial plots of the raw 
data, fitted values, residuals and either BLUEs or BLUPs, and a histogram of the BLUEs or 
BLUPs. When SpATS is used for modeling an extra plot with the fitted spatial trend is included (see [@RodAlv2018] and [@Velazco2017] for interpretation). 

Note that spatial plots can only be made if spatial information, i.e. "rowNum" and
"colNum", is available in the `TP` object.

```{r plotSpatRaw,  fig.height=4, fig.width=7, message=FALSE, eval=TRUE}
plot(modPhenoSp,
     timePoints = 36,
     plotType = "spatial",
     spaTrend = "raw")
```
For a straighforward interpretation of the fitted spatial trends and for comparison between
time points, the plot of the fitted spatial trend can be displayed as a ratio of the raw 
phenotypic mean: SpatTrend(proportion) = Estimated SpatTrend / mean(raw EffpsII). 
In this case, the scale will be in percentage and the min/max will be adjusted based on 
all the time points used but will be at least 10%. This empirical threshold allows 
visualising fitted trends that have a relatively small to large importance.

```{r plotSpatPerc,  fig.height=4, fig.width=7, message=FALSE, eval=TRUE}
plot(modPhenoSp,
     timePoints = 36,
     plotType = "spatial",
     spaTrend = "percentage")
```


It is also possible to create a time lapse of the ratio of spatial trends over time. The 
scale is the same as previoulsy described. The time lapse is always written to an
ouput file. 
```{r plotTimeLapse,  fig.height=5, fig.width=6, message=FALSE, eval=FALSE}
plot(modPhenoSp, 
     plotType = "timeLapse",
     outFile = "TimeLapse_modPhenoSp.gif")
```

Here is an illustration with three time points:
<center>
![Timelapse1](figures/timelapse_nogif.png){width=80%}
</center>


### Extracting model results

All results that can be extracted are shown in the table below. The first column
shows what function needs to be called in order to be able to extract the result.
The second column gives a short description of the result that will be extracted and, where
needed, also states for which modeling engines it can be extracted.

function |  description |
------------- | --------------------------------------------------------------- |
getGenoPred | Best Linear Unbiased Predictions (BLUPS, genotype as random) or Estimators (BLUEs, genotype as fixed) |
getCorrected | Spatially corrected values at the experimental unit level |
getVar | Variance components |
getHerit | Generalised heritabilities - only when genotype is random |
getEffDims | Extract effective dimensions - only for SpATS engine |

By default, all the functions run for all the time points. It is possible to select some of them using `timePoints`. The ratio of the effective dimensions can also be extracted using `EDType = "ratio"` in the `getEffDims` function. 

The output of the function `getGenoPred` is a list of two dataframes: "genoPred" which contains the predicted values for all tested genotypes and "checkPred" which contains the predicted values of the check genotypes, when `useCheck = TRUE` in the model. "checkPred" is empty when `useCheck = FALSE`.


```{r getFun, message=FALSE}
## Extract the genotypic predictions for one time point: 
genoPredSp <- getGenoPred(modPhenoSp, timePoints = 6)
## Extract the corrected values for one time point: 
spatCorrSp <- getCorrected(modPhenoSp, timePoints = 6)
## Extract model components: 
varianceSp <- getVar(modPhenoSp)
heritSp    <- getHerit(modPhenoSp)
effDimSp   <- getEffDims(modPhenoSp)
```

The genotypic predictions of the test genotypes for one time point are displayed in a table like the following:

```{r getPred, echo=FALSE, message=FALSE}
knitr::kable(head(genoPredSp$genoPred), align = c('c','c','c','c','c'), padding = 0)
```


The corrected values are obtained by subtracting the estimated sources of variation which are of no interest to the raw data:  
$CorrData = RawData - EstSpatial - EstRow - EstCol - EstCovar$  
This allows keeping the data at the experimental unit level (plants) and having more degrees of freedom for further modeling (e.g. time course modeling and estimation of the time course parameter(s)). 

> *TO NOTE: all the estimated fixed effects included in `extraFixedFactors` are removed from the corrected phenotype (EstCovar).* 

The corrected values of one time point are displayed in a table
like the following:

```{r getCorr, echo=FALSE, message=FALSE}
knitr::kable(head(spatCorrSp), align = c('c','c','c','c','c','c','c'), padding = 0)
```

### Plotting model results

Different plots can be displayed for the `fitMod` object. The first one is "rawPred", it plots the raw data (colored lines) overlayed with the predicted values (black line) from the fitted model. For each genotype a plot is made per plot/plant over time. These plots are put together in a 5×5 grid.   
By using the option `genotypes`, a subset of genotypes will be plotted. By default, data are plotted as point but this can be changed by setting `plotLine = TRUE`.

```{r plotSpPred, message=FALSE, fig.height=2, fig.width=6, fig.align = 'center'}
plot(modPhenoSp, 
     plotType = "rawPred",
     genotypes = c("check1", "check2", "G7", "G58")) 
```

The second one is "corrPred", it plots the spatially corrected data (colored lines) overlayed with the predicted values from the fitted model (black line). For each genotype a plot is made per plot/plant over time. These plots are put together in a 5×5 grid. 
By using the option `genotypes`, a subset of genotypes will be plotted. By default, data are plotted as point but this can be changed by setting `plotLine = TRUE`.

```{r plotSpCorr, message=FALSE, fig.height=2, fig.width=6, fig.align = 'center', eval=TRUE}
plot(modPhenoSp, 
     plotType = "corrPred",
     genotypes = c("check1", "check2", "G7", "G58") )
```

Note that when check genotypes are used for modelling, for the two previous plotType ("rawPred" and "corrPred"), the option `plotChecks` is required to display check genotypes.

```{r plotSpPredcheck, eval=FALSE, message=FALSE, fig.height=2, fig.width=6, fig.align = 'center'}
plot(modPhenoSpCheck, 
     plotType = "rawPred",
     plotChecks = TRUE,
     genotypes = c("check1", "check2", "G7", "G58")) 
```

The three last types of plot display different model parameters over time. Plot type "herit"
plots the heritability over time. If `geno.decomp` is used when fitting
the model, heritabilities are plotted for each level of variance decomposition in a
single plot (see section **3.4**). The scale of the plot can be adjusted using `yLim`.

```{r plotSpHerit, message=FALSE, fig.height=2.5, fig.width=3.5, fig.align = 'center'}
plot(modPhenoSp, 
     plotType = "herit",
     yLim = c(0.5,1))
```

Plot type "variance" plots the residual, column and row variances over time.
```{r plotSpVar, fig.height=3, fig.width=5, message=FALSE, fig.align = 'center'}
plot(modPhenoSp, 
     plotType = "variance")
```

Plot type "effDim" plots the effective dimension from model fitted using SpATS over time. 
By default, all the spatial components are plotted. This can be restricted using 
the option `whichED`.
```{r plotSpED, message=FALSE, fig.height=3, fig.width=5, fig.align = 'center'}
plot(modPhenoSp, 
     plotType = "effDim",
     whichED = c("colId", "rowId", "fColRow","colfRow", "surface"),
     EDType = "ratio")
```

The effective dimensions are also known as the effective degrees of freedom. They can be
interpreted as a measure of the complexity of the corresponding component: if the effective 
dimension of one component is large, it indicates that there are strong spatial trends 
in this direction. Here, for better comparison between components, the ratio of effective 
dimensions vs. total dimensions can be used. It has a value between 0, no spatial trend, 
and 1, strong spatial trend (almost all the degrees of freedom are used to model it).

## Spatial model with ASReml {#asreml}

When asreml is used for modeling and `spatial = TRUE`, four models are fitted with different 
random terms and covariance structures. The best model is determined based on a 
goodness-of-fit criterion, AIC, on 20% on the time points or at least 10 
time points. The best model is then run on all time points. As for SpATS, all the 
asreml models can be extended by fitting extra fixed factors using the option `extraFixedFactors`. 

> *Note that for the moment, it is only running with asreml-R version 4 only.*

| option | model fitted | spatial term |
|----------------------|------------------------------------------|-----------------|
| spatial = TRUE | trait = **genotype** + **row** + **col** + **$\epsilon$** | ar1(rowId):ar1(colId) |
|                | trait = **genotype** + **row** + **$\epsilon$** | ar1(rowId):colId |
|                | trait = **genotype** + **col** + **$\epsilon$** | rowId:ar1(colId) |
|                | trait = **genotype** + **row** + **col** + **$\epsilon$**|    - |
| spatial = TRUE, extraFixedFactors = c("A","B") | trait = *A* + *B* + **genotype** + **row** + **col** + **$\epsilon$** | ar1(rowId):ar1(colId) |
|                                         | trait = *A* + *B* + **genotype** + **row** + **$\epsilon$** | ar1(rowId):colId |
|                                         | trait = *A* + *B* + **genotype** + **col** + **$\epsilon$** | rowId:ar1(colId) |
|                                         | trait = *A* + *B* + **genotype** + **row** + **col** + **$\epsilon$** |  - |
| spatial = TRUE, repID = TRUE | trait = *repId* + **genotype** + **repId:row** + **repId:col** + **$\epsilon$** | ar1(rowId):ar1(colId) |
|                              | trait = *repId* + **genotype** + **repId:row** + **$\epsilon$** | ar1(rowId):colId |
|                              | trait = *repId* + **genotype** + **repId:col** + **$\epsilon$** | rowId:ar1(colId) |
|                              | trait = *repId* + **genotype** + **repId:row** + **repId:col** + **$\epsilon$** | - |

In the models above, fixed effects are indicated in *italics* whereas random 
effects are indicated in **bold**. "genotype" can be fitted as **random** or *fixed* effect using the option `what`. The same model will run with genotype as fixed. The option `useCheck` is not displayed in the table but works the same as for SpATS: treating some genotypes as check (see section [**3.1**](#spats) for details).

Calling asreml is done by changing the `engine` option in the `fitModels` function.

```{r fitSpASReml, message=FALSE}
if (requireNamespace("asreml", quietly = TRUE)) {
## Fit a model on few time points with spatial function:
modPhenoSpAs <- fitModels(TP = phenoTPOut, 
                          trait = "EffpsII",
                          timePoints = seq(from = 1, to = 73, by = 5),
                          engine = "asreml",
                          spatial = TRUE) 
summary(modPhenoSpAs)
}
```

Here the best spatial model is: trait = **genotype** + **row** + **col** + **$\epsilon$**, 
with a spatial component: **ar1(rowId):ar1(colId)**. It has been selected using 10 time points. 

Plotting and extracting results is then done the same way as for SpATS. Below are few examples.

```{r getFunAs, message=FALSE}
if (requireNamespace("asreml", quietly = TRUE)) {
 spatCorrSpAs <- getCorrected(modPhenoSpAs, timePoints = 6)
}
```

```{r getCorrAs, echo=FALSE, message=FALSE}
if (requireNamespace("asreml", quietly = TRUE)) {
 knitr::kable(head(spatCorrSpAs), align=c('c','c','c','c','c','c','c'), padding = 0)
}
```

```{r plotSpAsHerit, message=FALSE, fig.height=2.5, fig.width=3.5, fig.align = 'center'}
if (requireNamespace("asreml", quietly = TRUE)) {
plot(modPhenoSpAs, 
     plotType = "herit",
     yLim = c(0.5, 1))
}
```

Note that when the engine is asreml, the heritability is calculated using the formula 
provided in [@Cullis2006].

# Modeling without spatial terms with ASReml {#asremlnoSP}

When the row and column coordinates are not available, only asreml can be used for modeling.
In that case, the model simply uses the genotype and the extraFixedFactors, if any.

| option | model fitted | spatial term |
|------------------------------------|------------------------|-------------------|
| spatial = FALSE | trait = **genotype** + **$\epsilon$** |  - |
| spatial = FALSE, extraFixedFactors = c("A","B") | trait = *A* + *B* + **genotype** + **$\epsilon$** | - |

In the models above and below, fixed effects are indicated in *italics* whereas random 
effects are indicated in **bold**. "genotype" can be fitted as **random** or *fixed* effect
using the option `what`. The same model will run with genotype as fixed. The option 
`useCheck` is not displayed in the table, but works the same as for SpATS (see section [**3.1**](#spats)).

```{r asremlNoSpat, eval=FALSE }
## Fit a model on few time points without spatial function.
modPhenoAs <- fitModels(TP = phenoTPOut, 
                        trait = "EffpsII",
                        timePoints = seq(from = 1, to = 73, by = 5),
                        engine = "asreml",
                        spatial = FALSE)
```

# Modeling with variance decomposition using Example 2 {#genodecomp}

When an experimental treatment is applied, for example, a water scenario, it is required
to decompose the genotypic variance into the levels of the treatment. In the following
example, two water scenarios, well-watered (WW) and water deficit (WD), were applied. Thus,
instead of modeling one genotypic variance, there will be one genotypic variance per treatment.
In this part, we will describe briefly what is specific of such modeling with the 
statgenHTP package using a another example dataset.

We will use the TP object `phenoTPOut` in which annotated time points have been replaced by NA (see *OutliersTime...HTP*).

```{r createTP2, warning=FALSE, echo=FALSE}
phenoTParch <- createTimePoints(dat = PhenoarchDat1,
                                experimentName = "Phenoarch",
                                genotype = "geno",
                                timePoint = "Time",
                                plotId = "pos",
                                rowNum = "Row",
                                colNum = "Col")
resuArchHTP <- detectPointOutliers(TP = phenoTParch,
                                   trait = "LA_Estimated",
                                   confIntSize = 5,
                                   mylocfit = 0.5)
phenoTParchOut <- removePointOutliers(phenoTParch,
                                      resuArchHTP)
```

## Modeling

Using the `geno.decomp` option when modeling will have two main consequences in the 
model: the `geno.decomp` variable(s) will be added as main fixed effect(s) and also as 
interaction(s) with the genotype effect (and the extraFixedFactors and/or check, if any, with spats only). 
The table below provides one example with three models:

| option | engine | model fitted | spatial term |
|--------------------|--------|-----------------------------------------|------------|
| geno.decomp = c("treatment") | spats | trait = *treatment* + **treatment:genotype** + **row** + **col** + **$\epsilon$** |  PSANOVA |
| geno.decomp = c("treatment"), useCheck = TRUE, extraFixedFactors = "covar1" | spats | trait = *treatment* + *treatment:covar1* + *treatment:check* + **treatment:genoCheck** + **row** + **col** + **$\epsilon$** |  PSANOVA |
| spatial = TRUE, geno.decomp = c("treatment") | asreml | trait = *treatment* + **treatment:genotype** + **row** + **col** + **$\epsilon$** | ar1(row):ar1(col) |

> *Note that for the moment, it is not possible to use the combination of geno.decomp and genotype as fixed.*

Using the Phenoarch example, we will apply a variance decomposition using the 
variables "Scenario" and "population":

```{r fitSpGD, message=FALSE, eval=TRUE}
modPhenoSpGD <- fitModels(TP = phenoTParchOut,
                          trait = "LA_Estimated",
                          geno.decomp = c("Scenario", "population"),
                          timePoints = seq(from = 1, to = 35, by = 3))
```

## Output

Extracting results and plotting from the models work exactly the same as previously. 
For example, the spatial plot on this dataset look like the following for one time point:

```{r plotSatASReml, echo=FALSE, message=FALSE, eval=TRUE, fig.height=4, fig.width=7, fig.align='center'}
plot(modPhenoSpGD,
     timePoints = 19,
     plotType = "spatial",
     spaTrend = "percentage")
```

There are some significant differences in the display of some results and plots. 
They are highlighted below.

The predictions have two values per genotype, one per combined level of `geno.decomp`, here "Scenario_population", as illustrated in the table below for three genotypes predicted from the SpATS model `modPhenoSpGD`.

```{r getPredSpGD, echo=FALSE, message=FALSE, eval=TRUE}
genoPredSpGD <- getGenoPred(modPhenoSpGD, timePoints = 16)
toto <- head(genoPredSpGD$genoPred[genoPredSpGD$genoPred$genotype %in% c("GenoA1","GenoA2","GenoB1","GenoB2"),], 8)
row.names(toto) <- 1:nrow(toto)
knitr::kable(toto, align = c('c','c','c','c','c','c'), padding = 0)
```

The heritabilities are now split into `geno.decomp` levels and their plot now displays one line per level.

```{r getHeritSpGD, echo=FALSE, message=FALSE}
genoHeritSpGD <- getHerit(modPhenoSpGD)
knitr::kable(head(genoHeritSpGD), align = c('c','c','c','c'), padding = 0)
```

```{r plotSpHeritGD, echo=FALSE, fig.align='center', fig.height=3, fig.width=5, message=FALSE}
plot(modPhenoSpGD, 
     plotType = "herit",
     yLim = c(0.4,1))
```

The prediction and corrected data plots display one plot per combination genotype × geno.decomp.

```{r plotSprawGD, echo=FALSE, message=FALSE, fig.height=4, fig.width=7, fig.align = 'center', eval=TRUE}
plot(modPhenoSpGD, 
     plotType = "rawPred",
     genotypes = c("GenoA1","GenoA2","GenoA3","GenoB1","GenoB2") )
```

----

## References

