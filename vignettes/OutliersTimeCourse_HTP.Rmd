---
title: "statgenHTP tutorial: 4. Outlier detection Time courses"
author: "Emilie Millet, Bart-Jan van Rossum, Isabelle Sanchez, Nadine Hilgert"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: yes
    toc: no
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{TimeCourse} 
  %\VignetteEncoding{UTF-8} 
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
  )
library(statgenHTP)
```

# Introduction 

It consists in detecting outliers in a set of time courses resulting from the observation of one single trait. 
The detection procedure is applied to each trait individually without considering other traits, meaning that distinct outlier datasets are associated with each considered trait. 

## A nonparametric smoothing associated with a PCA

Each time course is modelled by a nonparametric smoothing spline with a fixed number of
knots. This is a piecewise cubic polynomial (Eubank, 1999, Eilers et al. 2015) fitted with the
‘gam’ function of the R-package ‘mgcv’. The estimates for the spline coefficients are then
extracted per time course (typically per plant) and correlations between those coefficient
vectors are calculated to identify outlying time courses, i.e., plants. An outlying time course will have low correlation to the majority of time courses. To support the analysis by correlations, a principal component analysis can be done on the plant (time course) by spline coefficient matrix. A PCA plot of the plant scores will show the outlying plant.

 P-splines in generalized additive model (gam) 
... optimization of the smoothing coeficient. Left nb of knots to select.

This documents describes the procedures to detect outlying time course with examples on experimental data sets (see *Intro_HTP*). The data on which the procedures apply are the variables of interest. They may be variables measured directly or indirectly (through image analysis for example). The way they were obtained doesn't matter. 


----

# Illustration of the non-parametric smoothing associated with a PCA

The function `fitSpline()` fits a p-spline per plant for the selected `trait` using the number of `knots`
chosen by the user. In P-spline, the knots are equally spaced and their number can be large. The user should also chose an appropriate proportion of minimum number of time points that should be in the 
dataset per plant `perMinTP`. When a plant has less time point than the minimum, it will be skipped from the analysis.

Will only work when there are at least three replicates per genotypes. 

Conversion of time to numerical time to get same scale, can be providing by the user

The functions are illustrated with the three example data sets. For more information about the data, see *Intro_HTP*.

## Example 1

Using the data corrected for spatial trends and removing time points outliers (see blablabla)

```{r fitSplineVator, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
data(spatCorrVator)  
# Format the timepoint
spatCorrVator$timePoint <- lubridate::as_datetime(spatCorrVator$timePoint)
# Run the function to fit p-spline using the mgcv package on a subset of genotypes
subGeno <- c("G70","G160","G151","G179","G175","G4","G55")
#
fit.spline <- fitSpline(corrDat = spatCorrVator,
                        trait = "EffpsII_corr",
                        genotypes = subGeno,
                        knots = 50,
                        perMinTP = 0.8)
# Extracting the tables of predicted values and pspline coeficients
pred.Dat <- fit.spline$predDat
coef.Dat <- fit.spline$coefDat
```

The object `fit.spline` contains the predicted value (`pred.value` in the table below), i.e the values predicted using the P-spline model coefficients. 
prediction on denser grid: smallest gap between two time points / 9, so dividing the smallest gap in 10 segments.
Also contains first derivative in column `deriv` **(see part XXX about Parameters estimation)**

```{r headpredDat, echo=FALSE, message=FALSE, eval=TRUE}
knitr::kable(head(pred.Dat), align=c('c','c'), booktabs = TRUE)
```

Conversion of time to numerical time to get same scale, can be providing by the user, for example when using thermal time ar a manual conversion. In this example, we provide a new column with time as hour since first measurement.

```{r formatNum, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE}
timy <- data.frame(timePoint = unique(spatCorrVator$timePoint),
                   timePointP1 = c(unique(spatCorrVator$timePoint)[2:73],
                                   lubridate::ymd_hms("2018-06-18 16:37:00")),
                   timeNum = NA)
# diff between two time point in hour
timeNum <- sapply( 1:nrow(timy), function(x) {
    as.numeric(lubridate::ymd_hms(timy$timePointP1[x])-
                             lubridate::ymd_hms(timy$timePoint)[x])
})
timy$timeNumDiff <- c(0,timeNum[1:(length(timeNum)-1)])
# cum sum
timy$timeNum <- cumsum(timy$timeNumDiff)
# add to spatCorrVator
spatCorrVator$timeNumHour <- timy$timeNum[match(spatCorrVator$timePoint,timy$timePoint)]
```


```{r fitSplineVatorNum, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
fit.splineNum <- fitSpline(corrDat = spatCorrVator,
                        trait = "EffpsII_corr",
                        genotypes = subGeno,
                        knots = 50,
                        perMinTP = 0.8,
                        useTimeNumber = TRUE,
                        timeNumber = "timeNumHour")
```

We can visualise the p-spline prediction and first derivative for a subset of genotypes or for a subset of plant.

```{r plotSplGeno,  fig.height=4, fig.width=7, message=FALSE, eval=TRUE}
plot(fit.spline,
     genotypes = "G160")
```

```{r plotSplPlot,  fig.height=2.5, fig.width=4, message=FALSE, eval=TRUE}
plot(fit.spline,
     plotIds = "c10r29",
     plotType =  "predictions")
plot(fit.spline,
     plotIds = "c10r29",
     plotType =  "derivatives")
```


The object `fit.spline` also contains the values of the P-splines coefficients:

```{r headcoefDat, echo=FALSE, message=FALSE, eval=TRUE}
knitr::kable(head(coef.Dat), align=c('c','c'), booktabs = TRUE)
```

The coefficients are then used to tag suspect time courses with the function `detectOutliers()`. This function performs a PCA on the coefficients (from data frame `coef.Dat`) per `genotype` and tags the plants that have a coordinate on the second PC axis above a threshold (`thrPca`), see the lines 'reason = pc2' in the table below. The function also calculates the pairwise-correlation of the coefficients per genotype. Plants are tagged when the correlation is below a given threshold (`thrCor`), see the lines 'reason = mean corr' in the table below. 

```{r OutVator, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
outVator <-
  detectTimeCourseOutliers(corrDat = spatCorrVator,
                           predDat = pred.Dat,
                           coefDat = coef.Dat,
                           trait = "EffpsII_corr",
                           genotypes = subGeno,
                           thrCor = 0.9,
                           thrPca = 1) 
```


```{r headOutPoint, echo=FALSE, message=FALSE, eval=TRUE}
knitr::kable(head(outVator), align=c('c','c'), booktabs = TRUE, row.names=F)
```
 
The `outVator` can be visualised by selecting genotypes:

```{r plotOutVator,  fig.height=6, fig.width=6, echo=TRUE, message=FALSE, warning=FALSE}
plot(outVator, genotypes = "G4")
```

The output of the outliers detection. A PCA plot of the plant scores will show the outlying plant. For example, when looking
at time courses of plant replicates for a single genotype (Fig.6A), one can inspect correlation
coefficients (Pearson’s r, Fig.6B) and a PCA plot of plant time courses (Fig. 6C) to identify
possible outliers.

```{r rmOutVator}
spatCorrVatorOut <- removeTimeCourseOutliers(dat = spatCorrVator,
                                            timeCourseOutliers = outVator)
# Check one value annotated as outlier in the original corrected data frame
head(spatCorrVator[spatCorrVator$plotId=="c21r25",
                  c("EffpsII_corr","EffpsII")])
# Check the same value in the new corrected data frame
spatCorrVatorOut[spatCorrVatorOut$plotId=="c21r25",
                c("EffpsII_corr","EffpsII")]
```



### Illustration with nb of knots

Number of knots:
```{r fitSplineVatorKnots10, fig.height=3, fig.width=4, echo=TRUE, warning=FALSE, eval=TRUE}
sp10k <- fitSpline(corrDat = spatCorrVator,
                        trait = "EffpsII_corr",
                        plotIds = "c10r29",
                        knots = 10,
                        perMinTP = 0.8)
plot(sp10k)
```


```{r fitSplineVatorKnots50, fig.height=3, fig.width=4, echo=TRUE, warning=FALSE, eval=TRUE}
sp50k <- fitSpline(corrDat = spatCorrVator,
                        trait = "EffpsII_corr",
                        plotIds = "c10r29",
                        knots = 50,
                        perMinTP = 0.8)
plot(sp50k)
```

## Example 2

Using the data corrected for spatial trends and removing time points outliers (see blablabla)

```{r fitSplineArch, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
data(spatCorrArch)  
spatCorrArch$timePoint <- lubridate::as_datetime(spatCorrArch$timePoint)
subGeno <- c("GenoA1","GenoA2","GenoA3","GenoA4","GenoB1","GenoB2","GenoB3")
#
fit.splineArch <- fitSpline(corrDat = spatCorrArch, 
                            trait = "Biomass_Estimated_corr",
                            genotypes = subGeno,
                            knots = 15,
                            perMinTP = 0.5)
#
pred.DatArch <- fit.splineArch$predDat
coef.DatArch <- fit.splineArch$coefDat
```

```{r plotArch,  fig.height=3, fig.width=4, message=FALSE, eval=TRUE}
plot(fit.splineArch,
     plotIds = "c11r9",
     plotType =  "predictions")
plot(fit.splineArch,
     plotIds = "c11r9",
     plotType =  "derivatives")
```

Here, the `geno.decomp` option is also used to split then plants of each genotypes between 
well watered and drought. The outliers detection is run per treatment.

```{r OutArch, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
outArch <- 
  detectTimeCourseOutliers(corrDat = spatCorrArch,
                           predDat = pred.DatArch,
                           coefDat = coef.DatArch,
                           trait = "Biomass_Estimated_corr",
                           genotypes = subGeno,
                           thrCor = 0.9,
                           thrPca = 1,
                           geno.decomp = "geno.decomp")
```

```{r headOutPointArch, echo=FALSE, message=FALSE, eval=TRUE}
knitr::kable(head(outArch), align=c('c','c'), booktabs = TRUE, row.names=F)
```

```{r plotOutArch,  fig.height=6, fig.width=6, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
plot(outArch, genotypes = "GenoB3")
```

```{r rmOutArch}
spatCorrArchOut <- removeTimeCourseOutliers(dat = spatCorrArch,
                                            timeCourseOutliers = outArch)
# Check one value annotated as outlier in the original corrected data frame
head(spatCorrArch[spatCorrArch$plotId=="c17r40",
                  c("Biomass_Estimated_corr","Biomass_Estimated")])
# Check the same value in the new corrected data frame
spatCorrArchOut[spatCorrArchOut$plotId=="c17r40",
                c("Biomass_Estimated_corr","Biomass_Estimated")]
```


 

## Example 3

Using the data corrected for spatial trends and removing time points outliers (see blablabla)
Only genotypes with 3 plants or more are selected here.

```{r fitSplineRoot, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
noCorrRoot$timePoint <- lubridate::as_datetime(noCorrRoot$timePoint)
subGeno <- c( "2","6","8","9","10","520","522")
fit.splineRoot <- fitSpline(corrDat = noCorrRoot,
                            trait = "tipPos_y",
                            knots = 10,
                            genotypes = subGeno,
                            perMinTP = 0.001,
                            useTimeNumber = TRUE,
                            timeNumber = "thermalTime")

pred.DatRoot <- fit.splineRoot$predDat
coef.DatRoot <- fit.splineRoot$coefDat
row.names(coef.DatRoot) <- 1:nrow(coef.DatRoot)
```


```{r plotRoot,  fig.height=4, fig.width=7, message=FALSE, eval=TRUE}
plot(fit.splineRoot,
     genotypes = "2")
```

```{r OutRoot, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
outRoot <- detectTimeCourseOutliers(corrDat = noCorrRoot,
                                    predDat = pred.DatRoot,
                                    coefDat = coef.DatRoot,
                                    trait = "tipPos_y",
                                    genotypes = as.character(subGeno),
                                    thrCor = 0.9,
                                    thrPca = 1.2)

```

```{r plotRootOut,  fig.height=6, fig.width=7, message=FALSE, eval=TRUE}
plot(outRoot,
     genotypes = "2")
```


```{r rmOutRoot}
noCorrRootOut <- removeTimeCourseOutliers(dat = noCorrRoot,
                                            timeCourseOutliers = outRoot)
# Check one value annotated as outlier in the original corrected data frame
head(noCorrRoot[noCorrRoot$plotId=="A_53_4","tipPos_y"])
# Check the same value in the new corrected data frame
noCorrRootOut[noCorrRootOut$plotId=="A_53_4","tipPos_y"]
```


# Extraction parameters from curve

After all the steps of cleaning and modeling... blablabla extract parameters from the curve
that are relevant for biology. Some examples are provided below for each data set.

## Example 1

```{r fitSplineVatorGeno, echo=TRUE, message=FALSE, warning=FALSE, eval=FALSE}

subGeno <- c("G70","G160","G151","G179","G175","G4","G55")

fit.spline <- fitSpline(corrDat = spatPredVator,
                        trait = "EffpsII_corr",
                        genotypes = subGeno,
                        knots = 50,
                        perMinTP = 0.8)

pred.Dat <- fit.spline$predDat
coef.Dat <- fit.spline$coefDat
row.names(coef.Dat) <- 1:nrow(coef.Dat)
```





----

## References

